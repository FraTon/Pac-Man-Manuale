:-[predicati_pacman].
:-[database].

:-dynamic limiti_x/2.
:-dynamic limiti_y/2.
:-dynamic limiti_campo_x/2.
:-dynamic limiti_campo_y/2.
:-dynamic scatter/3.

/*
       ************* SI POTREBBEERO METTERE LE ASSERZIONI DEI TUNNEL NEL
       DATABASE**********************************************


	*/

% OPERAZIONI INIZIALI
%
% Esegue delle operazioni iniziali necessarie
%
operazioni_iniziali:-
	limiti_muri,     %calcola i limiti Min e Max di X e Y
	cerca_tunnel,	 %individua e asserisce eventuali tunnel
        scatter_arancione.  %asserisce il punto di scatter del fantasma arancione



% LIMITI MURI
%
% Individa i limiti del campo da gioco imposti dalla posizione
% delle pareti.
%
% Asserisce la Max X e Y e la Min X e Y del campo
% da gioco.
%
limiti_muri:-
	findall([X,Y],muro(X,Y),Muri),
	max_min_x_y(Muri,MaxX,MaxY,MinX,MinY),
	assert(limiti_x(MinX,MaxX)),
	assert(limiti_y(MinY,MaxY)).

% MAX MIN X Y
%
% Data una lista contenente tutti i muri del gioco, individua i limiti
% del gioco e quindi il valore della Max X e Y accettabili e della Min X
% e Y accettabili.
%
max_min_x_y([],-10000,-10000,10000,10000).
max_min_x_y([[X,Y]|C],MaxAttualeX,MaxAttualeY,MinAttualeX,MinAttualeY):-
	max_min_x_y(C,MaxX,MaxY,MinX,MinY),
	MaxAttualeX is max(MaxX,X),
	MaxAttualeY is max(MaxY,Y),

	MinAttualeX is min(MinX,X),
	MinAttualeY is min(MinY,Y).




% CERCA TUNNEL
%
% Analizza la colonna corrispondente a MaxX (lato destro del campo da
% gioco) e la riga corrispondente a MaxY (lato superiore del campo da
% gioco) e controlla. Se l'intera riga/colonna è composta da muri, in
% questo di caso sicuramente non ci saranno tunnel. Se invece la
% riga/colonna non sono "piene", potrebbe esserci un tunnel, quindi si
% cerca un'interruzione della continuità del muro, se viene rilevata e
% nel muro opposto, in corrispondenza della stessa colonna/riga non c'è
% un muro, si asserisce il tunnel.
%
%
cerca_tunnel:-
	limiti_x(MinX,MaxX),
	limiti_y(MinY,MaxY),

	setof(Y,muro(MaxX,Y),MuroDx),
	setof(X,muro(X,MaxY),MuroSopra),

	length(MuroDx,Destra),
	length(MuroSopra,Sopra),

	(
	    %valore_assoluto(MaxY,Max1),
	    %valore_assoluto(MinY,Min1),
	    Destra is MaxY-MinY +1  % +1 perchè devo tenere conto del fatto che la prima riga è 0 e non 1
	    ;
	    cerca_interruzioni(x,MaxX,MuroDx,Interruzioni1),
	    verifica_tunnel(x,Interruzioni1)
	),

	(
	    %valore_assoluto(MaxX,Max2),
	    %valore_assoluto(MinX,Min2),
	    Sopra is MaxX - MinX +1
	    ;
	    cerca_interruzioni(y,MaxY,MuroSopra,Interruzioni2),
	    verifica_tunnel(y,Interruzioni2)
	).


% CERCA INTERRUZIONI MURO DESTRA
%
% Cerca un'interruzione della continuità dela parete di destra.
%
cerca_interruzioni(x,XFissa,MuroDx,Interruzioni):-

	primo_elemento(MuroDx,Primo),
	ultimo_elemento(MuroDx,Ultimo),

	%cerca celle non murarie nella parete di dx,  tra il primo e l'utimo elemento murarario trovati
	findall(Y,(vuota(XFissa,Y),Y>Primo,Y<Ultimo),Vuote),   %celle senza puntini tra il primo e l'utimo elemento murarario trovati
	findall(Y,(puntino(XFissa,Y),Y>Primo,Y<Ultimo),Puntino),   %celle con puntini  tra il primo e l'utimo elemento murarario trovati
	findall(Y,(vitamina(XFissa,Y),Y>Primo,Y<Ultimo),Vitamina),  %celle con vitamine  tra il primo e l'utimo elemento murarario trovati

	append(Puntino,Vitamina,Punti),
	append(Punti,Vuote,Interruzioni).

% CERCA INTERRUZIONI MURO SUPERIORE
%
% Cerca un'interruzione della continuità dela parete superiore.
%
cerca_interruzioni(y,YFissa,MuroSopra,Interruzioni):-
	primo_elemento(MuroSopra,Primo),
	ultimo_elemento(MuroSopra,Ultimo),

	%cerca celle non murarie nella parete di superiore, tra il primo e l'utimo elemento murario trovati
	findall(X,(vuota(X,YFissa),X>Primo,X<Ultimo),Vuote), %celle senza puntini tra il primo e l'utimo elemento murarario trovati
	findall(X,(puntino(X,YFissa),X>Primo,X<Ultimo),Puntino),  %celle con puntini  tra il primo e l'utimo elemento murarario trovati
	findall(X,(vitamina(X,YFissa),X>Primo,X<Ultimo),Vitamina),  %celle con vitamine  tra il primo e l'utimo elemento murarario trovati

	append(Puntino,Vitamina,Punti),
	append(Punti,Vuote,Interruzioni)	.

% PRIMO ELEMENTO
%
% Individua il primo elemento di una lista
%
primo_elemento([T|_],T).

% ULTIMO ELEMENTO
%
% Individua l'ultimo elemento di una lista
%

ultimo_elemento([Ultimo],Ultimo).
ultimo_elemento([_|C],Ultimo):-
	ultimo_elemento(C,Ultimo).



% VERIFICA TUNNEL
%
% Data una lista di possibli tunnel verifica se sono effettivamente dei
% tunnel, ed in caso affermativo li asserisce.
%
% Per capire se potrebbero essere dei tunnel, controlla se la
% corrispondente cella nella parete opposto (la cella in cui
% eventualmente dovrebbe arrivare pacman dopo aver attraversato il
% tunnel), contiene un muro, in quel caso sicuramente non abbiamo
% trovato un tunnel.
% Se invece la cella corrispondente nella parete opposta non contiene un
% muro, potrebbe effettiamente trattarsi di un tunnel, o solamente un
% cella fuori dal campo di gioco; in ogni caso viene asserita la
% presenza di un tunnel.

verifica_tunnel(_,[]).
verifica_tunnel(x,[T|C]):-
        verifica_tunnel(x,C),

	limiti_x(MinX,_),   %recupera il valore della variabile fissa

	\+muro(MinX,T),   %controlla se sulla stessa Y ma nella parete opposto (sinistra) non c'è il muro, in tal caso-> tunnel
	asserisci_tunnel(x,T,true).

verifica_tunnel(y,[T|C]):-
        verifica_tunnel(y,C),

	limiti_y(MinY,_),   %recupera il valore della variabile fissa

	\+muro(T,MinY),   %controlla se sulla stessa Y ma nella parete opposto (inferiore) non c'è il muro, in tal caso-> tunnel
	asserisci_tunnel(y,T,true).

% ASSERISCI TUNNEL
%
% Data la variabile fissa e il valore dell'altra varibile, viene
% asserita l'adiacenza tra le celle del tunnel
%
asserisci_tunnel(x,Y,true):-
	limiti_x(MinX,MaxX),
	assert(adiacente([MinX,Y],[MaxX,Y])),
	assert(adiacente([MaxX,Y],[MinX,Y])).
asserisci_tunnel(y,X,true):-
	limiti_y(MinY,MaxY),
	assert(adiacente([X,MinY],[X,MaxY])),
	assert(adiacente([X,MaxY],[X,MinY])).




scatter_arancione:-
	limiti_y(_,MaxY),

	Y is MaxY-1,
	setof(X,muro(X,Y),Muri),
	ultimo_elemento(Muri,Limite),

	findall(X,(puntino(X,Y),X<Limite),Puntini),
	findall(X,(vuota(X,Y),X<Limite),Vuote),

	%primo_elemento(Puntini,PrimoPuntino),
	%ultimo_elemento(Puntini,UltimoPuntino),
	massimo_lista(Puntini,UltimoPuntino),   % massima coordinata x tra le celle della riga MaxY-1 che contiene un puntino

	%primo_elemento(Vuote,PrimVuota),
	massimo_lista(Vuote,UltimaVuota),   % massima coordinata x tra le celle della riga MaxY-1 che è vuota

	%primo_elemento(Vitamine,PrimaVitamina),
	%ultimo_elemento(Vitamine,UltimaVitamina),    % massima coordinata x tra le celle della riga MaxY-1 che contiene un vitamina


	Max is max(UltimoPuntino,UltimaVuota),
	%Max2 is max(Max,UltimaVitamina),

	assert(scatter(arancione,Max,Y)).   %asserisce l'obiettivo del fantasma arancione in modalità scatter
/*
percorso_scatter_arancione(Max2,Max):-
	assert(modalita(arancione,scatter)),

	best(Max2,Max,arancione,Percorso),*/



% MASSIMO LISTA
%
% Individua il massimo valore contenuto in una lista.
%
massimo_lista([],-10000).
massimo_lista([T],T):-
	!.
massimo_lista([T|C],MaxAttuale):-
	massimo_lista(C,Max),
	MaxAttuale is max(T,Max).

% MINIMO LISTA
%
% Individua il minimo valore contenuto in una lista.
%
minimo_lista([],10000).
minimo_lista([T],T):-
	!.
minimo_lista([T|C],MinAttuale):-
	minimo_lista(C,Min),
	MinAttuale is min(T,Min).

