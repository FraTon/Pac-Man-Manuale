%:- [predicati_pacman].
%:-[crea_database].
%:-[database].

:-dynamic pacman/2.
:-dynamic fantasma/3. %ultima posizione conosciuta del fantasma Colore
:-dynamic scatter/3.
:-dynamic obiettivo/4.  %(modalita,colore,X obietivo, Y obiettivo)
:-dynamic possibili/3.
:-dynamic percorso/3.   %percorso(modalita,colore,Percorso)
:-dynamic modalita/2.   %modalita(Colore,std/fuga/mangiato)
:-dynamic vecchio_pacman/2.

:-discontiguous mossa_fantasma/6.
%   *************************************************************SISTEMAREMOVIMENTO ARANCION (SCATTER) *******
%   *********************************************


% MUOVI FANTASMI DIREZIONE FANTASMA ROSSO ME LA DEVO
% CALCOLARE!!!!!!!!!!!!!!!!!!????????????????????????????????????????????
% ?????????????????????????
%



% ASSERISCI VECCHIO PACMAN
%
asserisci_vecchio_pacman:-
       ritratta(vecchio_pacman),
       pacman(PX,PY),
       assert(vecchio_pacman(PX,PY)).



% SET MODALITA
%
% Setta la modalità specificata per il fantasma specificato
%
set_modalita(Colore,Modalita):-
       ritratta(modalita,Colore),
       assert(modalita(Colore,Modalita)).   %asserisce la nuova modalita

% NON MOSSO PACMAN
%
% Date le attuali coordinate di Pac-Man, verifica se si è spostato
% dall' ultima posizione conosciuta, in tal caso fallisce.
%
non_mosso_pacman(PX,PY):-
	vecchio_pacman(X,Y),
	X is PX, %verifica se la vecchia coordinata X (@X) di Pac-Man coincide con l'attuale coordinata X (@PX)
	Y is PY. %verifica se la vecchia coordinata Y (@Y) di Pac-Man coincide con l'attuale coordinata Y (@PY)



%prendi_la_testa([T|L],L,T).

% MOSSA FANTASMA ROSSO SE PACMAN NON SI è MOSSO
%
/*mossa_fantasma(rosso,X,Y,NX,NY,Dir):-
        pacman(PX,PY),
        non_mosso_pacman(PX,PY),  %NON SI è MOSSO
        !,

	%ROSSO: prendo la mossa successiva del percorso ottimo già calcolato
	percorso(std,rosso,[[NX,NY]|RestoDelPercorsoRosso]),
	percorso(std,rosso,PercorsoRosso),
        %prendi_la_testa(PercorsoRosso,RestoDelPercorsoRosso,[NX,NY]),
        cancella_testa(PercorsoRosso,[[NX,NY]|RestoDelPercorsoRosso]),
	incrementa_posizione(X,Y,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa


	ritratta(fantasma,rosso),
	assert(fantasma(rosso,X,Y)),   %asserisce l'ultima posizione conosciuta

	ritratta(percorso,rosso),
        assert(percorso(std,rosso,RestoDelPercorsoRosso)).  %asserisco il resto del percorso ottimo
**/


% MOSSA FANTASMA ARANCIONE CON DISTANZA INFERIORE A 8 DA PACMAN
% ***********************************************************************
% **
%
% Data la posizione attuale del fantasma (FX,FY) restituisce la
% nuova posizione (mossa successiva) in cui dovrà spostarsi per
% raggiungere il suo obiettivo (NX,NY).

% Se la distanza in linea d'aria tra il fantasma e Pac-Man è inferiore a
% 8, il fantasma ha come obiettivo il suo punto di scatter (angolo in
% alto a destra), se si trova già nel suo punto di scatter, deve girare
% nel suo angolo.
%
% Come cosa iniziale si verifica se si è in modalità std e ci si trova
% ad un incrocio, solo in quel caso si cerca una direzione da seguire,
% in caso contrario infatti il fantasma non può cambiare direzione ed è
% costretto a proseguire nello stesso verso.
%
mossa_fantasma(Colore,FX,FY,NX,NY,Dir):-
	modalita(Colore,Modalita),
	Modalita = 'std',

	direzioni_ammissibili(Colore,FX,FY,NX,NY),
	incrementa_posizione(FX,FY,Dir,1,NX,NY).  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

mossa_fantasma(arancione,FX,FY,NX,NY,Dir):-
	pacman(PX,PY),

        distanza([FX,FY],[PX,PY],DistanzaPacman), %calcola la distanza in linea d'aria che c'è tra il fantasma e pacman
	DistanzaPacman > 8,%controlla se la distanza calcolata è maggiore di 8
	!,
        Colore = 'arancione',
	%mossa_fantasma(Colore,FX,FY,NX,NY,Dir).   %si comporta come il fantasma rosso
	modalita(Colore,Modalita),

        ritratta(obiettivo,Colore),
        assert(obiettivo(Modalita,Colore,PX,PY)), %asserisce il suo obiettivo

	best(FX,FY,Colore,Percorso), %calcola percorso ottimo verso il suo obiettivo
	%scrivi(Percorso),

	mossa(Percorso,[NX,NY],NuovoPercorso),  % [NX,NY] coordinate della cella in cui muoversi per avvicinarsi all'obiettivo
	incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

	ritratta(percorso,Colore),
	assert(percorso(Modalita,Colore,NuovoPercorso)), %asserisce percorso

	ritratta(fantasma,Colore),
	assert(fantasma(Colore,FX,FY)).   %asserisce l'ultima posizione conosciuta



% distanza da Pac-Man minore o uguale a 8
% Pac-Man ha raggiunto il suo punto si scatter -> percorso scatter
%
mossa_fantasma(arancione,FX,FY,NX,NY,Dir):-
        raggiunto_scatter(FX,FY),%controllo se il fantasma ha già raggiunto il suo punto scatter
	!,

	%fantasma ha già raggiunto l'angolo ->deve girare nei pressi dell'angolo->obiettivo:precedente posizione senza però poter tornare indietro
	fantasma(arancione,VX,VY),	    %precedente posizione
	modalita(arancione,Modalita),

        ritratta(obiettivo,arancione),
        assert(obiettivo(Modalita-scatter,arancione,VX,VY)),  %obiettivo: precedente posizione

	best(FX,FY,arancione,Percorso),
	%scrivi(Percorso),
	mossa(Percorso,[NX,NY],NuovoPercorso),    % [NX,NY] coordinate della cella in cui muoversi per avvicinarsi all'obiettivo
        incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

	ritratta(percorso,arancione),
	assert(percorso(Modalita-scatter,arancione,[NuovoPercorso|[FX,FY]])),  %asserisce percorso scatter aggiungendo in coda la posizione attuale in modo che compia un ciclo

	ritratta(fantasma,arancione),
	assert(fantasma(arancione,FX,FY)).   %asserisce l'ultima posizione conosciuta



% distanza da Pac-Man minore o uguale a 8
% Pac-Man ha già raggiunto il suo punto di scatter e sta già eseguendo
% il percorso scatter-> mossa successiva del percorso
%
mossa_fantasma(arancione,FX,FY,NX,NY,Dir):-
	modalita(arancione,Modalita),
	percorso(Modalita-scatter,arancione,Percorso),  %sta già eseguendo un percorso scatter
	!,

	cancella_testa(Percorso,[[NX,NY]|RestoPercorso]),  %esegue la mossa successiva
	incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

	(
            \+percorso(Modalita-scatter,arancione,_)
             ;
             retract(percorso(Modalita-scatter,arancione,_))
        ),
	assert(percorso(Modalita-scatter,arancione,RestoPercorso)),

	ritratta(fantasma,arancione),
        assert(fantasma(arancione,FX,FY)).   %asserisce l'ultima posizione conosciuta

% distanza da Pac-Man minore o uguale a 8
% Pac-Man non ha ancora raggiunto il suo punto di scatter-> percorso
% per raggiungerlo
%
mossa_fantasma(arancione,FX,FY,NX,NY,Dir):-
	scatter(arancione,X,Y),
	modalita(arancione,Modalita),

	retract(obiettivo(_,arancione,_,_)),
        assert(obiettivo(Modalita,arancione,X,Y)),

	best(FX,FY,arancione,Percorso),
	%scrivi(Percorso),
	mossa(Percorso,[NX,NY],NuovoPercorso),    % [NX,NY] coordinate della cella in cui muoversi per avvicinarsi all'obiettivo
	incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

	retract(percorso(_,arancione,_)),
	assert(percorso(Modalita,arancione,NuovoPercorso)),  %asserisce percorso

	retract(fantasma(arancione,_,_)),
	assert(fantasma(arancione,FX,FY)).   %asserisce l'ultima posizione conosciuta




% MOSSA FANTASMA ROSSO o ARANCIONE SE HA UNA DISTANZA SUPERIORE AD 8 DA
% PAC-MAN
%
% Data la posizione attuale del fantasma (FX,FY) restituisce la
% nuova posizione (mossa successiva) in cui dovrà spostarsi per
% raggiungere il suo obiettivo (NX,NY).
%
% Il suo obiettivo è Pac-Man stesso.
%
% Si è già verificato se ci si trova ad un incrocio.
%
mossa_fantasma(Colore,FX,FY,NX,NY,Dir):-
	pacman(PX,PY),   % istanzia PX e PY con le attuali coordinate di pacman
	modalita(Colore,Modalita),

        ritratta(obiettivo,Colore),
        assert(obiettivo(Modalita,Colore,PX,PY)), %asserisce il suo obiettivo

	best(FX,FY,Colore,Percorso), %calcola percorso ottimo verso il suo obiettivo
	%scrivi(Percorso),

	mossa(Percorso,[NX,NY],NuovoPercorso),  % [NX,NY] coordinate della cella in cui muoversi per avvicinarsi all'obiettivo
	incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

	ritratta(percorso,Colore),
	assert(percorso(Modalita,Colore,NuovoPercorso)), %asserisce percorso

	ritratta(fantasma,Colore),
	assert(fantasma(Colore,FX,FY)).   %asserisce l'ultima posizione conosciuta







% MOSSA FANTASMA AZZURRO CONTROLLARE SE DISTANZA MANHATTAN O LINEA
% D'ARIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
%
%
%
%
%
%
% Data la posizione attuale del fantasma (FX,FY) restituisce la
% nuova posizione (mossa successiva) in cui dovrà spostarsi per
% raggiungere il suo obiettivo (NX,NY).
%
% Per calcolare il suo obiettivo, è necessario calcolare le coordinate
% della cella a distanza 2 da Pac-Man lungo la direzione in cui si sta
% muovendo, poi calcolare la distanza in linea d'aria tra la cella
% appena definita [IX,IY] e la posizione del fantasma rosso [F1_X,F1_Y].
%
% L'obiettivo del fantasma azzurro si trova lungo la direzione del
% fantsma rosso, a una distanza doppia (rispetto a quella calcolata)
% dalla sua posizione.
%
% Come cosa iniziale si verifica se ci si trova ad un incrocio, solo in
% quel caso si cerca una direzione da seguire, in caso contrario infatti
% il fantasma non può cambiare direzione ed è costretto a proseguire
% nello stesso verso.
%
% Come cosa iniziale si verifica se si è in modalita standard e ci si
% trova ad un incrocio, solo in quel caso si cerca una direzione da
% seguire, in caso contrario infatti il fantasma non può cambiare
% direzione ed è costretto a proseguire nello stesso verso.
%
mossa_fantasma(azzurro,FX,FY,_,_,_,_,NX,NY,Dir):-
	modalita(azzurro,Modalita),
	Modalita = 'std',

	direzioni_ammissibili(azzurro,FX,FY,NX,NY),
	incrementa_posizione(FX,FY,Dir,1,NX,NY).  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa


mossa_fantasma(azzurro,FX,FY,FRX,FRY,DirezioneFR,DirezionePacMan,NX,NY,Dir):-
	pacman(PX,PY),   % istanzia PX e PY con le attuali coordinate di pacman
	modalita(azzurro,Modalita),

	incrementa_posizione(PX,PY,DirezionePacMan,2,IX,IY),  % [IX,IY] è la cella e distanza 2 da pacman lungo la sua direzione
	distanza([FRX,FRY],[IX,IY],Distanza),  %calcolo della @Distanza tra [IX,IY] e l'attuale posizione del fantasma rosso [F1_X,F1_Y]
	obiettivo_azzurro(FRX,FRY,DirezioneFR,Distanza,X,Y),  %calcolo obiettivo del fantasma

	obiettivo_ammissibile(X,Y,OX,OY), %verifica l'ammissibilità dell'obiettivo calcolato e in base a questo determina il valore di OX,OY
	ritratta(obiettivo,azzurro),
	assert(obiettivo(Modalita,azzurro,OX,OY)), %asserisce il suo obiettivo

	best(FX,FY,azzurro,Percorso), %calcola percorso ottimo verso il suo obiettivo
	%scrivi(Percorso),
	mossa(Percorso,[NX,NY],NuovoPercorso), % [NX,NY] coordinate della cella in cui muoversi per avvicinarsi all'obiettivo
	incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa


	ritratta(percorso,azzurro),
	assert(percorso(Modalita,azzurro,NuovoPercorso)), %asserisce percorso

	ritratta(fantasma,azzurro),
	assert(fantasma(azzurro,FX,FY)).   %asserisce l'ultima posizione conosciuta


% MOSSA ROSA SE PACMAN NON SI è MOSSO E IL FANTASMA ROSA NON HA ACORA
% RAGGIUNTO IL SUO OBIETTIVO
mossa_fantasma(rosa,X,Y,NX,NY,Dir):-
        pacman(PX,PY),
        non_mosso_pacman(PX,PY),  %NON SI è MOSSO
        obiettivo(std,rosa,OX,OY),

        %controlla se non ha raggiunto il suo obiettivo
	\+ OX is X,
	\+ OY is Y,
        !,

	%rosa non ha ancora raggiunto il suo obiettivo e pacman non si è mosso, quindi prendo il percorso ottimo ed eseguo la mossa successiva
	percorso(std,rosa,PercorsoRosa),
	cancella_testa(PercorsoRosa,[[NX,NY]|RestoDelPercorsoRosa]),
	incrementa_posizione(X,Y,Dir,1,NX,NY), %conosce la posizione attuale e la successiva,lo spostamento è unitario->Direzione percorsa

        ritratta(fantasma,rosa),
	assert(fantasma(rosa,X,Y)),   %asserisce l'ultima posizione conosciuta

	ritratta(percorso,rosa),
	assert(percorso(std,rosa,RestoDelPercorsoRosa)).




% MOSSA FANTASMA ROSA
%
% Data la posizione attuale del fantasma (FX,FY) restituisce la
% nuova posizione (mossa successiva) in cui dovrà spostarsi per
% raggiungere il suo obiettivo (NX,NY).

% L'obiettivo del fantasma rosa , si trova 4 celle più avanti rispetto
% alla posizione di Pac-Man e lungo la sua direzione.
%
% Come cosa iniziale si verifica se si è in modalità standard e ci si
% trova ad un incrocio, solo in quel caso si cerca una direzione da
% seguire, in caso contrario infatti il fantasma non può cambiare
% direzione ed è costretto a proseguire nello stesso verso.
%
mossa_fantasma(rosa,FX,FY,_,NX,NY,Dir):-
	modalita(rosa,Modalita),
	Modalita = 'std',

	direzioni_ammissibili(rosa,FX,FY,NX,NY),
	incrementa_posizione(FX,FY,Dir,1,NX,NY).  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa


mossa_fantasma(rosa,FX,FY,DirezionePacMan,NX,NY,Dir):-
        pacman(PX,PY),

	incrementa_posizione(PX,PY,DirezionePacMan,4,IX,IY),  % [IX,IY] è la cella e distanza 4 da pacman lungo la sua direzione
	obiettivo_ammissibile(IX,IY,OX,OY),  %verifica l'ammissibilità dell'obiettivo
	ritratta(obiettivo,rosa),
	assert(obiettivo(std,rosa,OX,OY)), %asserisce il suo obiettivo

	best(FX,FY,rosa,Percorso), %calcola percorso ottimo verso il suo obiettivo
	%scrivi(Percorso),
	mossa(Percorso,[NX,NY],NuovoPercorso), % [NX,NY] coordinate della cella in cui muoversi per avvicinarsi all'obiettivo
	incrementa_posizione(FX,FY,Dir,1,NX,NY),  % conosce la posizione attuale e la successiva,lo spostamento è unitario-> Direzione percorsa

	ritratta(percorso,rosa),
	assert(percorso(std,rosa,NuovoPercorso)), %asserisce percorso ottimo

	ritratta(fantasma,rosa),
	assert(fantasma(rosa,FX,FY)).   %asserisce l'ultima posizione conosciuta




% DIREZIONI AMMISSIBILI
%
% Calcola in quante direzioni è possibile muoversi a partire dalla cella
% (FX,FY).
%
% Se la direzione possibile è solo una, si consente al fantasma di
% tornare indietro.
% Se le direzioni possibili sono solo due, si obbliga il fantasma a
% proseguire lungo la sua direzione, infatti un fantsma può cambiare
% direzione solo in corrispondenza di una intersezione.
%
direzioni_ammissibili(Colore,FX,FY,NX,NY):-
	successori([FX,FY],Successori),
	length(Successori,N),
	N=<2,
	!,
	fantasma(Colore,PrecedenteX,PrecedenteY),
	prossima_mossa(Successori,[PrecedenteX,PrecedenteY],[NX,NY]),

	ritratta(obiettivo,Colore),
        ritratta(percorso,Colore),
        ritratta(fantasma,Colore),
	assert(fantasma(Colore,FX,FY)). %aggiorno l'ultima posizione conosciuta




prossima_mossa([X,Y],[X,Y],[X,Y]). % una sola possibile mossa  non credo i verifichi mai
%due mosse possibili
prossima_mossa([[X,Y]|C],[X,Y],C).
prossima_mossa([T|[X,Y]],[X,Y],T).

/*	(   X is FX,
	    Y is FY,
	    Lista is C
	    ;
	    Lista is [X,Y]
	).

*/



% INCREMENTA POSIZIONE
%
% Date le coordinate (@X,@Y) di una cella, calcola le coordinate delle
% cella (@IX,@IY) a distanza N lungo la direzione specificata.
%
%
%
%(problema, se va nel tunnel????????????? o fuori dai limiti)
%
%
%

% Direzione 0 = DESTRA
incrementa_posizione(X,Y,0,N,IX,IY):-
	IX is X+N,
	IY is Y.
% Direzione 1 = GIU'
incrementa_posizione(X,Y,1,N,IX,IY):-
	IX is X,
	IY is Y-N.
% Direzione 2 = SINISTRA
incrementa_posizione(X,Y,2,N,IX,IY):-
	IX is X-N,
	IY is Y.
% Direzione 3 = SU
incrementa_posizione(X,Y,3,N,IX,IY):-
	IX is X,
	IY is Y+N.
%Tunnel da destra
incrementa_posizione(34,-14,0,1,1,-14).

%Tunnel da sinistra
incrementa_posizione(1,-14,2,1,34,-14).


%DISTANZA
%
% Calcola la distanza in linea d'aria tra [X1,Y1] e [X2,Y2].
%
distanza([X1,Y1],[X2,Y2],Distanza):-
    Distanza is sqrt(((X1-X2)^2)+((Y1-Y2)^2)).

% OBIETTIVO AZZURRO
% Calcola l'obiettivo del fantasma axxurro.
%
obiettivo_azzurro(F1_X,F1_Y,DirezioneF1,Distanza,IX,IY):-
    Distanza2 is round(Distanza*2), %Calcolo il doppio della distanza
    incrementa_posizione(F1_X,F1_Y,DirezioneF1,Distanza2,IX,IY). %Incremento coordinate posizione medusa rossa del doppio della distanza


%MOSSA
%
% Dato un percorso, ne restituisce la mossa da effettuare (penultima
% mossa).
%

mossa(Percorso,Mossa,RestoDelPercorso):-
    inverti(Percorso,PercorsoInvertito),  %inverte il percorso
    cancella_testa(PercorsoInvertito,[Mossa|RestoDelPercorso]). %cancella il primmo elemento del percorso invertito



%INVERTI LISTA
%
inverti([],[]).

inverti([T|C],L):-
    inverti(C,C2),
    append(C2,[T],L).

% CANCELLA TESTA
%
% Cancella il primo elemento della lista.
%
cancella_testa([_|C],C).
cancella_testa([_],_).



% OBIETTIVO AMMISSIBILE
%
% Controlla l'ammissibilità dell'obiettivo calcolato, restiruisce le
% coordinate dell'obiettivo da raggiungere.
%
% Le coordinate restituite coincidono con quelle in input se ricadono
% all'interno del campo da gioco in un'area raggiungibie, in caso
% contrario, viene restituita la posizione di Pac-Man che sarà
% l'obiettivo del fantasma in questione.
%
obiettivo_ammissibile(OX,OY,OX,OY):-
	\+ muro(OX,OY),
	(
	       puntino(OX,OY)
	       ;
	       vuota(OX,OY)
	       ;
	       vitamina(OX,OY)

	 ).
obiettivo_ammissibile(_,_,PX,PY):-
	pacman(PX,PY).




raggiunto_scatter(FX,FY):-
        scatter(arancione,X,Y),  %istanzia le coordinate dell'obiettivo del fantasma arancione in modalitò scatter
	X is FX,
	Y is FY.


ritratta(pacman):-
       (
           \+pacman(_,_)
           ;
           retractall(pacman(_,_))
       ).

ritratta(vecchio_pacman):-
       (
           \+vecchio_pacman(_,_)
           ;
           retractall(vecchio_pacman(_,_))
        ).
ritratta(modalita,Colore):-
       (
            \+ modalita(Colore,_)    % se per quel colore c'è già un obiettivo asserito-> fallisce,
            ;
            retractall(modalita(Colore,_)) % e lo ritratta
        ).
ritratta(obiettivo,Colore):-
       (
            \+ obiettivo(_,Colore,_,_)    % se per quel colore c'è già un obiettivo asserito-> fallisce,
            ;
            retractall(obiettivo(_,Colore,_,_)) % e lo ritratta
        ).
ritratta(percorso,Colore):-
       (
            \+ percorso(_,Colore,_)    % se per quel colore c'è già un percorso assertìito-> fallisce,
            ;
            retractall(percorso(_,Colore,_)) % e lo ritratta
        ).

ritratta(fantasma,Colore):-
       (
           \+ fantasma(Colore,_,_)
           ;
           retractall(fantasma(Colore,_,_))
       ).

% SCRIVI
scrivi([]) :- nl.
scrivi([T|C]) :-
	scrivi(C),
	write(' '), write(T), nl.
